"""
Evaluate the chatGPT/GPT-4 models.


"""
import argparse, os
import json
import pandas as pd
import re
from collections import defaultdict, Counter

def readArgs ():
    parser = argparse.ArgumentParser (description="Evaluate the performance of each model")
    parser.add_argument ("--groundtruth-file", type=str, required=True, help="File contains the groundtruth labels")
    parser.add_argument ("--dirname", type=str, required=True, help="Directory name")
    parser.add_argument ("--output-file", type=str, required=True, help="Output file")
    args = parser.parse_args()
    return args

def extract_text(items):
    """Extracts the text from a list of items where each item is of the form of `<tag> some text </tag>`.
    Code generated by Bard
   
    Args:
    items: A list of items.
   
    Returns:
    A list of strings containing the text from each item.
    """

    # Create a regular expression to match the text between the opening and closing tags.
    pattern = re.compile(r'<(.+)>(.*?)</\1>')

    # Iterate over the items and extract the text.
    results = []
    for item in items:
        match = pattern.match(item)
        if match:
            results.append(match.group(2))

    return results

def read_results_file_for_example (dirname, idd):
    filename = os.path.join (dirname, f"{idd}.txt")
    with open (filename) as fin:
        text = fin.read ()

    _, _, _,_, response = text.split ('\t')
    response = json.loads (response)

    return response

def chatgpt_response_parser (response):
    items = extract_text (response['choices'][0]['message']['content'].split ('\n'))
    items = [item if not "</label>" in item else item.split ('</label>')[0].replace ('<label>', '') for item in items]
    return items

def check_accuracy1 (truth, char_valid, place_valid):
    if char_valid == "valid" and place_valid == "valid":
        return truth == "VALID"
    else:
        return truth == "INVALID"

def model_valid_prediction (char_valid, place_valid):
    return "VALID" if char_valid == "valid" and place_valid == "valid" else "INVALID"
    
def check_accuracy (truth, prediction):
    return truth != "N/A" and truth.upper() == prediction.upper()

def main (args):
    groundtruth_df = pd.read_csv (args.groundtruth_file, sep='\t')
    groundtruth_df = groundtruth_df.fillna('N/A')
    accuracies = defaultdict (float)
    for i, row in groundtruth_df.iterrows ():
        response = read_results_file_for_example (args.dirname, row["ID"])
        items = chatgpt_response_parser (response)
        valid_prediction = model_valid_prediction (items[2].strip(), items[3].strip())
        accuracies ["valid_relation"] += check_accuracy (row["valid_relation"], valid_prediction)
        accuracies ["spatial_relation"] += check_accuracy (row["spatial_relation"], items[4].strip())
        accuracies ["temporal_span"] += check_accuracy (row["temporal_span"], items[5].strip())
        accuracies ["narrative_tense"] += check_accuracy (row["narrative_tense"], items[6].strip())
    
    accuracies["valid_relation"] = accuracies["valid_relation"] / len (groundtruth_df)
    accuracies["spatial_relation"] = accuracies["spatial_relation"] / len (groundtruth_df.query('spatial_relation != "N/A"'))
    accuracies["temporal_span"] = accuracies["temporal_span"] / len (groundtruth_df.query('temporal_span != "N/A"'))
    accuracies["narrative_tense"] = accuracies["narrative_tense"] /len (groundtruth_df.query('narrative_tense != "N/A"'))
    print (accuracies)

    with open (args.output_file, "w") as fout:
        fout.write (f"dirname\tvalid_relation\tspatial_relation\ttemporal_span\tnarrative_tense\n")
        fout.write (f"{os.path.abspath(args.dirname)}\t{accuracies['valid_relation']:.4f}\t{accuracies['spatial_relation']:.4f}\t{accuracies['temporal_span']:.4f}\t{accuracies['narrative_tense']:.4f}")
    

if __name__ == "__main__":
    main (readArgs ())